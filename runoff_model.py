# Phython Code for Geospatial Programming IND_STDY
    # Runoff Risk Index Mapping in Southern Arizona

    # This descriptor below allows the user to understand where this ArcPy script originated. In the case of this project, the script was generated from the ArcGIS ModelBuilder on December 15, 2025.
"""
Generated by ArcGIS ModelBuilder on : 2025-12-15 20:49:24
"""

    # The import arcpy function allows for Python to access ArcGIS tools; it is the funamental reason why Python can run the below processes and without using it, there would be no GIS tools that would work.
    # The next line 'from arcpy.sa import *' enables the spatial analyst tools in Arc. I used a bunch for this project, and by implementing this line of code with the *, I could actually run all my tools using the
        # spatial analyst feature without having to type arcpy.sa<tool> before every process.
import arcpy
from arcpy.sa import *

def Model():  # Model
    # The above line of code allows Arcpy to define the entire workflow as a new Model(), where every tool being ran in the geospatial workflow can be executed.

    # To allow for the overwriting of outputs, I changed the overwriteOutput option from 'False' to 'True'. This was done so tools that write to the same file name can sucessfully overwrite the previous file. In the
        # case of this script, I want it to be a repetable workflow, so adding the overwrite option is necessary. This also prevents stopping errors from Arcpy when the same outputs already exist. 
    # Line 22, scratchWorkplace line, is used to write the outputs from each tool ran into the project's scratch geodatabase. This is a workaround for the 'RuntimeError: ERROR 010240' message I would encounter when
        # trying to save to the project's original geodatabase.
    arcpy.env.overwriteOutput = True
    arcpy.env.scratchWorkspace = arcpy.env.scratchGDB

    # The two lines below are needed to check out any necessary licenses, making sure the tools are actually avaiable for use before running them.
    # Lines 30-32 are used as the three main input layers for my runoff analysis. Here, the script is loading in the three layers for use in the subsequent tools below. They are necessary inputs to reach a valid
        # weighted overlay product.
    arcpy.CheckOutExtension("spatial")
    arcpy.CheckOutExtension("3D")

    DEM_Merged_Clip = arcpy.Raster("DEM_Merged_Clip")
    ImpSurf_ClipProject = arcpy.Raster("ImpSurf_ClipProject")
    Soils_Clip_Proj = "Soils_Clip_Proj"

    # Process: Fill (Fill) (sa) is a step in the procedure used to fill the original DEM with a z-limit of 0.1m. This is crucial to ensuring continuity of the DEM for input into hydrological tools. Line 36 saves
        # the output layer to the scratchGBD location, as well as the remaining tools below with the line <layer_name> = arcpy.env.scratchGDB + r"<layer_name>".
    Fill_DEM_mb = arcpy.env.scratchGDB + r"\Fill_DEM_mb"
    Fill = Fill_DEM_mb
    Fill_DEM_mb = arcpy.sa.Fill(DEM_Merged_Clip, 0.1)
    Fill_DEM_mb.save(Fill)


    # Process: Flow Direction (Flow Direction) (sa) primarily executes flow direction in the D8 algorithm for the previous layer. Environment settings are temporarily set to match the cell size, grid allignment,
        # and extent of the DEM used. This applies to the remaining tools in this model.
    FlowDir_mb = arcpy.env.scratchGDB + r"\FlowDir_mb"
    Flow_Direction = FlowDir_mb
    Output_drop_raster = ""
    with arcpy.EnvManager(cellSize=Fill_DEM_mb, extent="405489.487867412 3429533.80736365 595526.519583412 3651793.06039965 PROJCS[\"NAD_1983_UTM_Zone_12N\",GEOGCS[\"GCS_North_American_1983\",DATUM[\"D_North_American_1983\",SPHEROID[\"GRS_1980\",6378137.0,298.257222101]],PRIMEM[\"Greenwich\",0.0],UNIT[\"Degree\",0.0174532925199433]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"False_Easting\",500000.0],PARAMETER[\"False_Northing\",0.0],PARAMETER[\"Central_Meridian\",-111.0],PARAMETER[\"Scale_Factor\",0.9996],PARAMETER[\"Latitude_Of_Origin\",0.0],UNIT[\"Meter\",1.0]]", snapRaster=Fill_DEM_mb):
        FlowDir_mb = arcpy.sa.FlowDirection(Fill_DEM_mb, "NORMAL", Output_drop_raster, "D8")
        FlowDir_mb.save(Flow_Direction)


    # Process: Flow Accumulation (Flow Accumulation) (sa) executes the flow accumulation tool. It is a product of the previous flow direction layer, where cells are given values based on the number of upslope cells
        # contributing flow into that pixel's location.
    FlowAcc_mb = arcpy.env.scratchGDB + r"\FlowAcc_mb"
    Flow_Accumulation = FlowAcc_mb
    with arcpy.EnvManager(cellSize=Fill_DEM_mb, extent="405489.487867412 3429533.80736365 595526.519583412 3651793.06039965 PROJCS[\"NAD_1983_UTM_Zone_12N\",GEOGCS[\"GCS_North_American_1983\",DATUM[\"D_North_American_1983\",SPHEROID[\"GRS_1980\",6378137.0,298.257222101]],PRIMEM[\"Greenwich\",0.0],UNIT[\"Degree\",0.0174532925199433]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"False_Easting\",500000.0],PARAMETER[\"False_Northing\",0.0],PARAMETER[\"Central_Meridian\",-111.0],PARAMETER[\"Scale_Factor\",0.9996],PARAMETER[\"Latitude_Of_Origin\",0.0],UNIT[\"Meter\",1.0]]", snapRaster=Fill_DEM_mb):
        FlowAcc_mb = arcpy.sa.FlowAccumulation(arcpy.Raster(Flow_Direction), "", "FLOAT", "D8")
        FlowAcc_mb.save(Flow_Accumulation)


    # Process: Slope (Slope) (sa) is a tool in this model that derives the slope angle in units of degrees, derived from the DEM. It is one of the fundamental tools needed for the weighted overlay model to work with
        # runoff.
    Slope_mb = arcpy.env.scratchGDB + r"\Slope_mb"
    Slope = Slope_mb
    with arcpy.EnvManager(cellSize=Fill_DEM_mb, extent="405489.487867412 3429533.80736365 595526.519583412 3651793.06039965 PROJCS[\"NAD_1983_UTM_Zone_12N\",GEOGCS[\"GCS_North_American_1983\",DATUM[\"D_North_American_1983\",SPHEROID[\"GRS_1980\",6378137.0,298.257222101]],PRIMEM[\"Greenwich\",0.0],UNIT[\"Degree\",0.0174532925199433]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"False_Easting\",500000.0],PARAMETER[\"False_Northing\",0.0],PARAMETER[\"Central_Meridian\",-111.0],PARAMETER[\"Scale_Factor\",0.9996],PARAMETER[\"Latitude_Of_Origin\",0.0],UNIT[\"Meter\",1.0]]", snapRaster=Fill_DEM_mb):
        Slope_mb = arcpy.sa.Slope(Fill_DEM_mb, "DEGREE", 1, "PLANAR", "METER", "GPU_THEN_CPU")
        Slope_mb.save(Slope)


    # Process: Reclassify (Reclassify) (sa) reclassifies the previous slope output in terms of values. Slope angles are manually grouped together and assigned a score. For example, the slope angles 0-5 are assigned 
        # a score of one as denoted by '"VALUE", "0 5 1; etc., "DATA"' below. Higher angles are given a higher score, and five scores were derived for the reclassification of this layer.
    Reclass_Slop_mb = arcpy.env.scratchGDB + r"\Reclass_Slop_mb"
    Reclassify = Reclass_Slop_mb
    with arcpy.EnvManager(cellSize=Fill_DEM_mb, extent="405489.487867412 3429533.80736365 595526.519583412 3651793.06039965 PROJCS[\"NAD_1983_UTM_Zone_12N\",GEOGCS[\"GCS_North_American_1983\",DATUM[\"D_North_American_1983\",SPHEROID[\"GRS_1980\",6378137.0,298.257222101]],PRIMEM[\"Greenwich\",0.0],UNIT[\"Degree\",0.0174532925199433]],PROJECTION[\"Transverse_Mercator\"],PARAMETER[\"False_Easting\",500000.0],PARAMETER[\"False_Northing\",0.0],PARAMETER[\"Central_Meridian\",-111.0],PARAMETER[\"Scale_Factor\",0.9996],PARAMETER[\"Latitude_Of_Origin\",0.0],UNIT[\"Meter\",1.0]]", snapRaster=Fill_DEM_mb):
        Reclass_Slop_mb = arcpy.sa.Reclassify(Slope_mb, "VALUE", "0 5 1;5 10 2;10 15 3;15 25 4;25 90 5", "DATA")
        Reclass_Slop_mb.save(Reclassify)


    # Process: Reclassify (2) (Reclassify) (sa) operates in a similar fashion to the above slope reclassification. Imperviousness of surfaces were grouped into five classes, or 'scores'. Highly impervious surfaces
        # were given the highest score.
    Reclass_Imp_mb = arcpy.env.scratchGDB + r"\Reclass_Imp_mb"
    Reclassify_2_ = Reclass_Imp_mb
    Reclass_Imp_mb = arcpy.sa.Reclassify(ImpSurf_ClipProject, "Value", "0 10 1;10 30 2;30 60 3;60 80 4;80 100 5", "DATA")
    Reclass_Imp_mb.save(Reclassify_2_)


    # Process: Polygon to Raster (Polygon to Raster) (conversion) is essential in this model since the soils layer downloaded from the ArcOnline portal were in the vector format, specifically as a shapefile polygon
        # layer. This tool converts those polygons to the raster format to be assigned a score in the following process.
    Soils_Polygons_mb = arcpy.env.scratchGDB + r"\Soils_Polygons_mb"
    arcpy.conversion.PolygonToRaster(in_features=Soils_Clip_Proj, value_field="RiskScore", out_rasterdataset=Soils_Polygons_mb, cellsize="9.259259")

    # Process: Reclassify (3) (Reclassify) (sa) is the final reclassification process used in the model. The rasterized soil polygons were grouped by their associated runoff risk. Group A soils (very high
        # infiltration) assigned a risk class of 1; group B (moderate-high) a class of 2; group C (moderate-low) a class of 3; group D (very low) into class 4. Dual soil groups were grouped 
        # into class 4, as their runoff potential is practially the same as group D soils. The scoring below reflects this, where classes 4 and 5 share the same end score of 5.
    Reclass_Soil_mb = arcpy.env.scratchGDB + r"\Reclass_Soil_mb"
    Reclassify_3_ = Reclass_Soil_mb
    Reclass_Soil_mb = arcpy.sa.Reclassify(Soils_Polygons_mb, "VALUE", "1 1;2 2;3 3;4 5 5", "DATA")
    Reclass_Soil_mb.save(Reclassify_3_)


    # Process: Weighted Overlay (2) (Weighted Overlay) (sa) could finally be implemented since now our major layers (soils, slope, and impervious surfaces) all share the same scores of 1-5. Weights were assigned to
        # each reclass layer, where slope had the highest weight at 40, impervious surfaces a weight of 35, and soils a weight of 25. The weights must add up to a value of 100 for the tool to work.
    # Lines 111-114 executes the full ModelBuilder workflow by calling the Model() function within a controlled ArcGIS environment when run directly.
    Weighted_Reclass_mb = arcpy.env.scratchGDB + r"\Weighted_Reclass_mb"
    Weighted_Overlay_2_ = Weighted_Reclass_mb
    Weighted_Reclass_mb = arcpy.sa.WeightedOverlay(WOTable([[Reclass_Slop_mb, 40 , 'Value' , RemapValue([[1, 1], [2, 2], [3, 3], [4, 4], [5, 5], ['NODATA', 'NODATA']])], [Reclass_Imp_mb, 35 , 'Value' , RemapValue([[1, 1], [2, 2], [3, 3], [4, 4], [5, 5], ['NODATA', 'NODATA']])], [Reclass_Soil_mb, 25 , 'Value' , RemapValue([[1, 1], [2, 2], [3, 3], [5, 5], ['NODATA', 'NODATA']])]], [1, 9, 1]))
    Weighted_Reclass_mb.save(Weighted_Overlay_2_)


if __name__ == '__main__':
    # Global Environment settings
    with arcpy.EnvManager(scratchWorkspace=arcpy.env.scratchGDB, workspace=arcpy.env.scratchGDB):
        Model()

